## 6 链表
* 链表为一种动态的数据结构，意味着可以任意添加和删除元素

本章内容
* 链表数据结构
* 向链表添加元素
* 从链表移除元素
* 使用LinkedList类
* 双向链表
* 循环链表
* 排序链表
* 通过链表实现栈

### 6.1 链表数据结构
- 存储多个元素，数组(或列表)可能是最常用的结构
- 我们可以使用[]来访问元素，但是从数组起点或中间插入元素或移除元素，成本很高
- **链表存储有序的元素集合**
- 与数组不同的是，链表在内存中并不是连续放置的，而是由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。
- 相比数组，链表在添加或移除元素时不需要移动其他元素
- 注意，在使用数组时，我们可以访问任意一个位置的元素，在使用链表时，访问中间的元素，需要迭代链表直到找到所需要的元素
- 例子: 手牵手跳舞，插入中间只需要断开两个人的链接，再重新链接起来
- 例子: 寻宝游戏，找的线索是通往下一个地方的指针
- 例子: 火车，火车每一截都包含自己和链接下一截的接口，我们很容易添加或者删除

### 6.2 链表和双向链表
#### 6.2.1 创建链表
* Node 类，创建一个元素和下一个元素的指针

需要实现的方法
| 方法      |  描述     |
| ------------------------  | -------- |
| push(elemeny)             | 向链表尾部添加一个新元素 |
| insert(element, position) | 向链表指定位置插入一个新元素 |
| getElementAt(index)       | 返回链表中特定位置的元素。如果链表中不存在这样的元素则返回undefined |
| remove(element)           | 从链表中移除一个元素 |
| indexOf(element)          | 返回元素在链表中的索引。如果链表中没有该元素则返回-1 |
| removeAt(position)        | 从链表特定位置删除一个元素 |
| isEmpty()                 | 如果链表中不包含任何元素，返回true，否则返回false |
| size()                    | 返回链表包含的元素个数 |
| toString()                | 返回表示整个链表的字符串。由于列表项使用了Node 类，就需要重写继承自js对象默认的toString 方法，让其只数据元素的值 |

#### 6.2.2 创建双向链表
- 双向链表元素继承链表元素，并扩展一个 指针prev 指向当前元素的上一个元素
- 双向链表需要重写链表插入和删除的逻辑

### 6.3 循环链表和循环双向链表
#### 循环链表
- 使用链表元素，末尾元素的指针指向 this.head
- 需重写 insert 和 removeAt 的逻辑
#### 循环双向链表 
- 使用双向链表元素，末尾元素 next 指针指向 this.head， 首位的 prev 指针指向末尾元素


### 6.4 有序链表
- 有序链表是指保持元素有序的链表结构，除了使用排序算法之外，我们可以将元素插入到正确的位置来保证链表的有序性。
- 不允许随意插入元素

### 6.5 创建StackLinkedList 类
- 在stack 类中使用 LinkedList 或 双向链表 来存储数据
- 我们向链表尾部添加元素，也会从链表尾部删除元素，双向链表保存最后一个元素的引用，无需迭代整个链表就能获取它
- 减少过程消耗，它的时间复杂度和原始的Stack 实现相同


## 小结
- 本章学习了 链表、双向链表、循环链表、有序链表
- 链表对比数组的优点有，**无需移动元素，就可以轻易的添加或删除元素**
- 因此，当需要**添加和移除很多元素**时，最好的选择就是链表，而非数据
- 本章还学习了如何使用一个链表来创建一个栈
- 以及复用其他数据结构中可用的方法有什么好处，而不是重写所有的逻辑代码